function [ h ] = reader()
%READER Create import data related local function handles

% import las
h.importlas = @ImportLAS;

% import well schematic xml generated by MIPS
h.importxml = @ImportWellSchematicXML;

% import collar .mip2 jont end table file
h.importcollar = @ImportEndsTable;

% import csv generated by ePDataAnalyzer
h.importcsv = @ImportCSV;

% import txt generated by COMSOL
h.importsim = @ImportComsolTxt;

% import user-defined ini config file for ePDT
h.readepdtcfg = @ReadePDTConfigIni;

% import ePDT calibration data ini
h.readepdtcal = @ReadePDTCalIni;

end

% -----------------------------------------------------------------

function [ data, header, detail ] = ImportLAS( filename )
%ImportLAS Import .las file
% Input:
%   filename    target file name
%
% Output:
%   data        numeric data
%   header      header of data
%   detail      structure of more detailed info

%% File Operations
% Open the text file.
fileID = fopen(filename, 'r');

% read in las as space delimited string
formatSpec = '%s%[^\n\r]';

% Read first 1000 lines to find header
textArray = textscan(fileID, formatSpec, 1000, 'Delimiter', ' ', ...
    'MultipleDelimsAsOne', true,  'ReturnOnError', false);

% find '~A' as the header line start, '#' for additional header lines
i_labeledheader = find(strcmp(textArray{1}, '~A') | ...
    strcmp(textArray{1}, '#')); 

% read header lines
i_header = GetTureHeader(textArray{2}(i_labeledheader), i_labeledheader);
[header, n_col] = Block2Vector(textArray{2}(i_header), 'string');

% Read in data block
frewind(fileID);
formatSpec = '%[^\n\r]';
dataArray = textscan(fileID, formatSpec, 'Delimiter', ' ', ...
    'MultipleDelimsAsOne', true, 'HeaderLines', i_labeledheader(end), ...
    'ReturnOnError', false);

% Close the text file.
fclose(fileID);

%% Data Output
% parse data block
row_block = length(i_header);
col_total = length(header);
raw = dataArray{1};
n_depth = length(raw) / row_block;

% read data
data = zeros(n_depth, col_total);
for i = 1:n_depth
    % read data lines by block
    [ data_depth, ~ ] = Block2Vector(raw((i - 1) * row_block + ...
        (1:row_block)), 'float');
    data(i, :) = data_depth;
end

% build detail structure for output
detail = struct;
detail.i_datastart = i_labeledheader(end) + 1;
detail.n_col = n_col;

end

function [ i_trueheader ] = GetTureHeader( data, i_header )
%GetTureHeader Remove empty lines of labeled header
% Input:
%   data            input data, n x 1 cell
%   i_header        labeled header lines
%
% Output:
%   i_trueheader    filled header lines

i_trueheader = zeros(size(i_header));
len = size(data, 1);

index = 1;
for i = 1:len
    line = strtrim(data{i});
    if isempty(line)
        continue;
    end
    i_trueheader(index) = i_header(i);
    index = index + 1;
end

i_trueheader = i_trueheader(1:(index - 1));

end

function [ output, n_col ] = Block2Vector( data, option )
%Block2Vector Convert block data to 1 dimensional vector
% Input:
%   data        input data, n x 1 cell
%   option      'string' or 'float'
%
% Output:
%   output      output data, 1 x m vector
%   n_col       column size, n x 1 vector

if strcmp(option, 'string')
    formatSpec = '%s';
    output = cell(1, 200);
    type = 1;
else
    formatSpec = '%f';
    output = zeros(1, 200);
    type = 2;
end

len = size(data, 1);
n_col = zeros(len, 1);
index = 0;
for i = 1:len
    if type == 1
        line = strsplit(strtrim(data{i}));
        n = size(line, 2);
    else
        [line, n] = sscanf(data{i}, formatSpec);
    end
    
    output(index + (1:n)) = line;
    index = index + n;
    n_col(i) = n;
end

if index > 0
    output = output(1:index);
else
    output = [];
    n_col = [];
end

end

% -----------------------------------------------------------------

function [ pipelist ] = ImportWellSchematicXML( filename )
%ImportWellSchematicXML Import well schematic in xml file
% Input:
%   filename    target file name
%
% Output:
%   pipeList    pipe list

% init structure
pipelist = struct;

% labels to read
labels = {'ItemID', 'TopDepth', 'BottomDepth', 'NomOD', 'NomThickness'};

% read xml file
xDoc = xmlread(filename);

% find all pipe section
allListitems = xDoc.getElementsByTagName('EMDSPipeSection');

% get listnode information
for i = 1:allListitems.getLength
    thisListitem = allListitems.item(i - 1);
   
    % read the labels
    for j = 1:length(labels)
        thisList = thisListitem.getElementsByTagName(labels{j});
        thisElement = thisList.item(0);
        pipelist(i).(labels{j}) = ...
            str2double(thisElement.getFirstChild.getData);
    end
end

end

% -----------------------------------------------------------------

function [ cl_bot, cl_top ] = ImportEndsTable( filename )
%ImportEndsTable Import .mip2 file for joint ends table
% Input:
%   filename    target file name
%
% Output:
%   cl_bot      bottom list of collars
%   cl_top      top list of collars

% open file
fileID = fopen(filename, 'r');

% read .csv file
formatSpec = '%*f%*f%*f%*f%*f%f%f%*s%*[^\n\r]';
dataArray = textscan(fileID, formatSpec, 'Delimiter', ',', ...
    'HeaderLines', 3, 'ReturnOnError', false);

% close file
fclose(fileID);

% collar table output
cl_bot = dataArray{:, 1};
cl_top = dataArray{:, 2};

end

% -----------------------------------------------------------------

function [ data, header ] = ImportCSV( filename, n_col )
%ImportCSV Import .csv file
% Input:
%   filename    target file name
%   n_col       number of columns to read
%
% Output:
%   data        numeric data
%   header      header of data

% create format string
headerFormatSpec = [repmat('%s', 1, n_col), '%*[^\n\r]'];
dataFormatSpec = [repmat('%f', 1, n_col), '%*[^\n\r]'];

% open file
fileID = fopen(filename, 'r');

% read header
headerArray = textscan(fileID, headerFormatSpec, 1, 'Delimiter', ',', ...
    'ReturnOnError', false);
header = [headerArray{:}];

% read data
dataArray = textscan(fileID, dataFormatSpec, 'Delimiter', ',', ...
    'HeaderLines' , 1, 'ReturnOnError', false);
data = [dataArray{:}];

% close file
fclose(fileID);

end

% -----------------------------------------------------------------

function [ data ] = ImportComsolTxt( filename, n_col )
%ImportComsolTxt Import COMSOL generated .txt file
% Input:
%   filename    target file name
%   n_col       number of columns to read
%
% Output:
%   data        numeric data

delimiter = ' ';
startRow = 6;
formatSpec = [repmat('%f', 1, n_col), '%[^\n\r]'];

fileID = fopen(filename, 'r');
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, ...
    'MultipleDelimsAsOne', true, 'HeaderLines', startRow - 1, 'ReturnOnError', false);
fclose(fileID);

data = [dataArray{:, 1:end-1}];

end

% -----------------------------------------------------------------

function [ status, info ] = ReadePDTConfigIni( filename, mode )
%ReadePDTConfigIni Read ePDT ini file for certain mode
% Input:
%   filename    target file name
%   mode        selected config mode
%
% Output:
%   status      success or not
%   info        config contents

status = false;
info = struct;
cfg_str = sprintf('[Config_%d]', mode);

info.configname = '';
info.cmdcode = '';
info.sensor = false(1, 3);      % enable status for S, M and L
info.txcurrent = zeros(1, 3);
info.txduration = zeros(1, 3);
info.chnum = zeros(1, 3);
info.chgain = cell(1, 3);       % unknown total channel number
info.chstarttime = [];
info.chendtime = [];
info.acq_idx_start = zeros(1, 3);
info.acq_idx_end = zeros(1, 3);
info.firingsequences = '';
info.fullsampletime = zeros(1, 3);
info.loggingspeed = 0;
info.adec_idx_start = zeros(1, 3);
info.adec_idx_end = zeros(1, 3);
info.chdelaytime = 20;          % defaulted to 20
info.turns = zeros(1, 3);
info.n_ch = 0;

fid = fopen(filename);
while ~feof(fid)
    line = fgetl(fid);
    if strcmp(line, cfg_str)    % locate the correct config
        while ~feof(fid) && ~isempty(line)
            line = fgetl(fid);  % read line by line
            paras = strsplit(line, '=');
            switch paras{1}
                case 'ConfigName'
                    info.configname = paras{2};
                case 'CmdCode'
                    info.cmdcode = paras{2};
                case 'SensorS'
                    info.sensor(1) = strcmpi(paras{2}, 'true');
                case 'SensorM'
                    info.sensor(2) = strcmpi(paras{2}, 'true');
                case 'SensorL'
                    info.sensor(3) = strcmpi(paras{2}, 'true');
                case 'TxCurrentS'
                    info.txcurrent(1) = str2double(paras{2});
                case 'TxDurationS'
                    info.txduration(1) = str2double(paras{2});
                case 'TxCurrentM'
                    info.txcurrent(2) = str2double(paras{2});
                case 'TxDurationM'
                    info.txduration(2) = str2double(paras{2});
                case 'TxCurrentL'
                    info.txcurrent(3) = str2double(paras{2});
                case 'TxDurationL'
                    info.txduration(3) = str2double(paras{2});
                case 'ChNumS'
                    info.chnum(1) = str2double(paras{2});
                case 'ChGainS'
                    info.chgain{1} = str2double(strsplit(paras{2}, ','));
                case 'ChNumM'
                    info.chnum(2) = str2double(paras{2});
                case 'ChGainM'
                    info.chgain{2} = str2double(strsplit(paras{2}, ','));
                case 'ChNumL'
                    info.chnum(3) = str2double(paras{2});
                case 'ChGainL'
                    info.chgain{3} = str2double(strsplit(paras{2}, ','));
                case 'ChStartTime'
                    info.chstarttime = str2double(strsplit(paras{2}, ','));
                case 'ChEndTime'
                    info.chendtime = str2double(strsplit(paras{2}, ','));
                case 'StartIdxSensorS'
                    info.acq_idx_start(1) = str2double(paras{2});
                case 'EndIdxSensorS'
                    info.acq_idx_end(1) = str2double(paras{2});
                case 'StartIdxSensorM'
                    info.acq_idx_start(2) = str2double(paras{2});
                case 'EndIdxSensorM'
                    info.acq_idx_end(2) = str2double(paras{2});
                case 'StartIdxSensorL'
                    info.acq_idx_start(3) = str2double(paras{2});
                case 'EndIdxSensorL'
                    info.acq_idx_end(3) = str2double(paras{2});
                case 'FiringSequences'
                    info.firingsequences = paras{2};
                case 'FullSampleTimeS'
                    info.fullsampletime(1) = str2double(paras{2});
                case 'FullSampleTimeM'
                    info.fullsampletime(2) = str2double(paras{2});
                case 'FullSampleTimeL'
                    info.fullsampletime(3) = str2double(paras{2});
                case 'LoggingSpeed'
                    info.loggingspeed = str2double(paras{2});
                case 'ADEC_S_START'
                    info.adec_idx_start(1) = str2double(paras{2});
                case 'ADEC_S_END'
                    if info.adec_idx_start(1) == 0
                        info.adec_idx_end(1) = -1;
                    else
                        info.adec_idx_end(1) = str2double(paras{2});
                    end
                case 'ADEC_M_START'
                    info.adec_idx_start(2) = str2double(paras{2});
                case 'ADEC_M_END'
                    if info.adec_idx_start(2) == 0
                        info.adec_idx_end(2) = -1;
                    else
                        info.adec_idx_end(2) = str2double(paras{2});
                    end
                case 'ADEC_L_START'
                    info.adec_idx_start(3) = str2double(paras{2});
                case 'ADEC_L_END'
                    if info.adec_idx_start(3) == 0
                        info.adec_idx_end(3) = -1;
                    else
                        info.adec_idx_end(3) = str2double(paras{2});
                    end
                case 'ChDelayTime'
                    info.chdelaytime = str2double(paras{2});
                case 'TurnsS'
                    info.turns(1) = str2double(paras{2});
                case 'TurnsM'
                    info.turns(2) = str2double(paras{2});
                case 'TurnsL'
                    info.turns(3) = str2double(paras{2});
            end
        end
        
        n_ch = sum(info.adec_idx_end - info.adec_idx_start + 1);
        if length(info.chstarttime) ~= length(info.chendtime) || ...
            n_ch > length(info.chstarttime)
            break;
        end
        
        info.n_ch = n_ch;                                                                                                            
        status = true;
        break;
    end
end
fclose(fid);

end

% -----------------------------------------------------------------

function [ status, header, configs ] = ReadePDTCalIni( filename )
%ReadCalIni Read calibration ini file.
% Input:
%  filename    calibration file name
%
% Output:
%  status      success or not
%  header      header info
%  configs     config contents

status = false;
header = struct;
configs = struct;

try
    fid = fopen(filename);
    while ~feof(fid)
        line = fgetl(fid);
        if strcmp(line, '[ePDT_CAL_Header]')
            % read header
            while ~feof(fid) && ~isempty(line)
                line = fgetl(fid);  % read line by line
                paras = strsplit(line, '=');
                switch paras{1}
                    case 'CAL_DATE'
                        header.datenum = str2double(paras{2});
                    case 'ToolSN'
                        header.sn = paras{2};
                    case 'FirmwareVersion'
                        header.fw = str2double(paras{2});
                    case 'CAL_CONFIG_NUM'
                        header.n_config = str2double(paras{2});
                end
            end
        elseif strcmp(line(1:10), '[ePDT_CAL_')
            % read config details
            while ~feof(fid) && ~isempty(line)
                line = fgetl(fid);  % read line by line
                paras = strsplit(line, '=');
                switch paras{1}
                    case 'PIPE_NUM'
                        n_pipe = str2double(paras{2});
                    case 'CORRODED_PIPE'
                        i_loss = str2double(paras{2});
                    case 'SChNum'
                        configs(n_pipe, i_loss + 1).n_ch_s = str2double(paras{2});
                    case 'SDecayLineNum'
                        n_lines = str2double(paras{2});
                        configs(n_pipe, i_loss + 1).sdecay = zeros(1, configs(n_pipe, i_loss + 1).n_ch_s);
                        for i = 1:n_lines
                            line = fgetl(fid);
                            paras = strsplit(line, '=');
                            configs(n_pipe, i_loss + 1).sdecay(100 * (i - 1) + ...
                                (1:min(100, configs(n_pipe, i_loss + 1).n_ch_s - 100 * (i - 1)))) = ...
                                str2double(strsplit(paras{2}, ','));
                        end
                    case 'MChNum'
                        configs(n_pipe, i_loss + 1).n_ch_m = str2double(paras{2});
                    case 'MDecayLineNum'
                        n_lines = str2double(paras{2});
                        configs(n_pipe, i_loss + 1).mdecay = zeros(1, configs(n_pipe, i_loss + 1).n_ch_m);
                        for i = 1:n_lines
                            line = fgetl(fid);
                            paras = strsplit(line, '=');
                            configs(n_pipe, i_loss + 1).mdecay(100 * (i - 1) + ...
                                (1:min(100, configs(n_pipe, i_loss + 1).n_ch_m - 100 * (i - 1)))) = ...
                                str2double(strsplit(paras{2}, ','));
                        end
                    case 'LChNum'
                        configs(n_pipe, i_loss + 1).n_ch_l = str2double(paras{2});
                    case 'LDecayLineNum'
                        n_lines = str2double(paras{2});
                        configs(n_pipe, i_loss + 1).ldecay = zeros(1, configs(n_pipe, i_loss + 1).n_ch_l);
                        for i = 1:n_lines
                            line = fgetl(fid);
                            paras = strsplit(line, '=');
                            configs(n_pipe, i_loss + 1).ldecay(100 * (i - 1) + ...
                                (1:min(100, configs(n_pipe, i_loss + 1).n_ch_l - 100 * (i - 1)))) = ...
                                str2double(strsplit(paras{2}, ','));
                        end
                end
            end
        end
    end
    fclose(fid);
catch
    return;
end

status = true;

end